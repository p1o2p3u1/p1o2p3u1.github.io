---
layout: post
title:  "MySql Innodb索引相关原理"
categories: mysql
---

# Innodb表结构

MySql表中所有的数据被存储在一个空间内，称为表空间。表空间又可以分为段、区、页、行，其逻辑结构如下图所示：

![](/assets/images/2018/logic-store-structure_gaitubao_com_895x595.png)

**段（Segment）**

表空间由不同的段组成，常见的段有：数据段，索引段，回滚段等。在MySql中，数据是用B+树来存储的，因此数据即索引，数据段及为B+树的叶子节点，索引段为B+树的非叶子节点，回滚段用来存储undo日志，用来事物失败后数据回滚以及在事物未提交之前通过undo日志获取之前版本的数据。

**区（Extent）**

区是由连续页组成的空间，每个区的空间固定大小为1MB。为保证区中页的连续性，Innodb会一次从磁盘中申请4~5个区，在默认不压缩的情况下，一个区可以容纳64个连续的页。但在开始建表的时候，空表的默认大小为96KB，是为了高效的利用磁盘空间，在开始插入数据时表会优先利用32个页大小的碎片页来存储数据，当这些碎片页用完之后，表大小才会按照MB倍数增加。

**页（Page）**

页是Innodb中用作数据存储的最小管理单位，每页是16KB，可以使用`innodb_page_size`来改变页的大小，但是改变只能在初始化Innodb实例之前进行修改，之后就无法修改。

**行（row）**

行对应的是表中的记录，每页存储的最多行记录规定为`16KB/2 - 200`, 即7992行。

# B树与B+树

B树和B+树常用于操作系统和文件系统中。B+树的特点是能够保持数据稳定有序，其插入和修改有较稳定的对数时间复杂度。

## B树

B树满足以下条件，可称之为m阶B树

 - 每个节点最多拥有m个子树
 - 跟节点至少拥有2个子树
 - 除了根节点外，每个分支节点至少拥有m/2个子树
 - 所有叶子节点都在同一层
 - 有k个子树的分支节点存在k-1个关键码，关键码按照递增顺序排列
 - 关键字数量n满足`ceil(m/2) - 1 <= n <= m-1`

**B树插入**

![](/assets/images/2018/b-tree-insert_gaitubao_com_955x1033.png)

**B树删除**

![](/assets/images/2018/b-tree-delete_gaitubao_com_963x1009.png)


## B+树

B+树满足以下条件，即可称之为m阶B+树：

 - 根节点只有一个，分支数量为`[2, m]`
 - 分支节点，每个节点包含的分支范围为`[ceil(m/2), m]`
 - 分支节点的关键字数量等于其分支的数量减一，关键字数量的范围为`[ceil(m/2)-1, m-1]`，关键字顺序递增
 - 所有叶子节点都在同一层

**B+树插入**

B+树的插入必须保证插入后叶节点中的记录依然有序，同事需要考虑插入B+树的三种情况，每种情况都会对应不同的插入算法，如下所示：

![](/assets/images/2018/b+-insert.png)

举例：
1. 在以下B+树种插入28，发现当前leaf page和index page都没有满，则直接插入

![](/assets/images/2018/b -insert1.png)

2. 插入70，此时leaf page已经满了，index page还没有满，根据中间的值60拆分叶子节点

![](/assets/images/2018/B -insert2.png)

3. 插入95，leaf page和index page都满了，此时需要做两次拆分

![](/assets/images/2018/B -insert3.png)

4. B+树是平衡树，为了保持平衡，对于新插入的值可能要做大量的拆分页操作。而B+树主要用于磁盘，拆分页意味着磁盘数据的移动，应该在尽可能的情况下减少拆分页。因此B+树提供了旋转的功能，旋转发生在leaf page已经满了，但左右兄弟节点没有满的情况下。此时B+树并不会急着去做拆页，而是将记录移到所在页的兄弟节点上，通常左边的兄弟首先用来检查做旋转操作。在第一张图的情况下，插入70，50、55、60、65旋转

![](/assets/images/2018/B -insert4.png)

**B+树删除**

B+树使用填充因子控制数的删除变化，50%是填充因子可设的最小值。B+树删除操作同样要考虑以下三种情况，与插入不同的是，删除根据填充因子的变化来衡量。

![](/assets/images/2018/b -delete.png)

举例：在插入第三点基础上的图

1. 删除70，直接删除

![](/assets/images/2018/b -delete1.png)

2. 删除25，该值还是index page中的值，因此在删除leaf page中的25的值后，还应将25的右兄弟节点的28更新到page index中

![](/assets/images/2018/b -delete2_gaitubao_com_1006x422.png)

3. 删除60，此时填充因子小于50%，需要做合并操作。同样在删除index page中相关记录后需要做index page的合并操作

![](/assets/images/2018/b -delete3_gaitubao_com_1016x366.png)

**B树和B+树的区别**

以m阶树为例：

 - 关键字不同：B+树分支节点有m个关键字，叶子节点也有m个关键字，但B树虽然有m个子节点，但其中只有m-1个关键字
 - 存储位置不同：B+树的非叶子几点只起到索引的作用，实际关键字在叶子节点；B树的非叶子节点也能存储关键字。
 - 分支构造不同：B+树的分支节点只包含索引信息
 - 查询不同：B树在找到具体的数值后即结束；B+树通过索引找到叶子节点的数据即结束。


# 聚簇索引和二级索引

## 聚簇索引

每个Innodb的表都拥有一个索引，称为聚簇索引，此索引中存储着行记录，一般是根据主键生成的。

聚簇索引按照以下规则创建：

 - 当定义了主键后，Innodb会利用主键生成聚簇索引
 - 当没有主键，Innodb会选择一个非空唯一索引来创建聚簇索引，此时唯一索引会充当主键。
 - 若也没有，Innodb会隐式创建一个自增列来作为聚簇索引

聚簇索引整体是一个B+树，非叶节点存储的是键值，叶子节点存放数据，称为数据页，因此**表中的数据也是索引的一部分,表中的数据也是索引的一部分,表中的数据也是索引的一部分**，也就是说叶子节点存放的是整张表的记录数据。数据页之间是通过一个双向链表来链接的，实现逻辑上的有序。

## 辅助索引

除了聚簇索引之外的索引都可以称之为辅助索引。与聚簇索引的区别是辅助索引的叶子节点中存放的是**主键的键值，主键的键值，主键的键值**。一张表可以有多个辅助索引，但只能有一个聚簇索引，通过辅助索引查找对应行记录的话需要两步：首先通过辅助索引定位到主键；第二部通过主键值在聚簇索引中找到对应的行记录，也就是两次B+树的检索。而通过辅助索引查询主键的话，就只需要一次遍历辅助索引就可以定位主键了，即**索引覆盖**，不用再检索聚簇索引。

创建辅助索引，可以使用一个或多个字段。当使用多个字段的时候，索引的键就不是一个值了，而是多个，如下图：

![](/assets/images/2018/union-index.png)

 - 联合索引的B+树和单个键值辅助索引的B+树是一样的，键值都是有序的。如上图中的键按照`(a,b)`这种形式`(1,1)(1,2)(2,1)(2,4)(3,1)(3,4)`进行存放。
 - 当使用`select * from table where a=? and b=?`可以使用索引加速查询，但如果使用`select * from table where b=?`时索引效率会下降，甚至无法使用索引，因为有个索引最左原则。
 - 索引最左原则：当创建复合索引时，假设索引字段为`(a,b)`，会先对a字段进行排序，在a字段有序的基础上，再对b字段进行排序。所以a字段是必定有序，而b字段就不一定了，所以直接使用第二个字段通常是用不到索引的。
 - 辅助索引还有一个概念是索引覆盖，即查询只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。由于辅助索引不会包含一整行的记录，因此能够减少IO。

# SQL执行顺序

{% highlight sql linenos %}
 FROM <left_table>
 ON <join_condition>
 <join_type> JOIN <right_table>
 WHERE <where_condition>
 GROUP BY <group_by_list>
 WITH `{CUBE|ROLLUP}`
 HAVING <having_condition>
 SELECT
 DISTINCT <select_list>
 ORDER BY <order_by_list>
 LIMIT <limit_number>
{% endhighlight %}

1. from: 对left_table和right_table进行笛卡尔积，形成虚表v1
2. on：对虚表v1进行on条件筛选，形成虚表v2
3. join：指定out join会将未匹配行添加到v2形成v3，若有多张表，会重复1~3
4. where：对v3进行条件过滤，形成v4。where是从左往右执行的。
5. group by：对v4分组得到v5
6. cube：对v5进行`CUBE|ROLLUP`得到v6
7. having：对v6进行过滤得到v7
8. select：执行选择操作得到v8
9. distinct：对v8去重得到v9
10. order by: 对v9排序得到v10
11. limit：对v10截取得到v11，返回给用户。

# SQL优化

索引优点：减少数据扫描量，避免排序和临时表，将随机IO变为顺序IO。

**可使用B+树索引的查询方式**

 - 全值匹配：即和索引中的所有列进行匹配，条件字段和索引字段的个数和顺序相同。
 - 最左前缀：只使用联合索引前几个字段
 - 匹配列前缀：比如`like 'xx%'`可以走索引
 - 范围匹配：如范围查询`between and, <>, like`等
 - 匹配某一列并范围匹配另一列：精确查询+范围查询
 - 只访问索引：索引覆盖，即select字段为主键。

**索引字段区分度**

在建联合索引的时候，区分度高的字段放在左边，这样可以在第一个条件就过滤掉大量的数据，有利于提升性能。


**了解MySql的查询过程**

![](/assets/images/2018/query-theory_gaitubao_com_1023x777.png)
