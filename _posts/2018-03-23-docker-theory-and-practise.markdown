---
layout: post
title: "docker原理与实践"
categories: docker
---

## 虚拟化

虚拟化是一种资源管理技术，将计算机的各种资源予以抽象、转换后呈现出来,打破实体结构间的不可切割的障碍，使用户可以比原本更好的方式来应用这些资源。

### Hypervisor（虚拟层）

 - 一种运行在基础物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享硬件。
 - Hypervisor可以捕获CPU的指令，为指令访问硬件控制器和外设充当中介。

Hypervisor两种模型：native hypervisor和hosted hypervisor

![](/assets/images/2018/hypervisor-types.jpeg)

native hypervisor:
 - 虚拟机运行在系统硬件上，创建硬件仿真实例，直接调用管理硬件资源，不需要底层操作系统。hypervisor可以看做一个很薄的操作系统。
 - 运行效率较高

hosted hypervisor：
 - 运行在传统操作系统之上，构建出一套虚拟硬件平台
 - 运行效率较低

### 虚拟化与容器差异

![](/assets/images/2018/difference-vm-container.jpeg)

![](/assets/images/2018/difference-vm-container2.jpeg)

虚拟化好处：
 - 更高的资源利用率
 - 降低管理成本
 - 提高使用灵活性

容器好处：
 - 轻量，秒级的快速启动
 - 简单，易用，灵活的社区
 - 标准统一的打包，部署，运行方案。
 - 镜像支持增量分发，易于部署
 - 内存以及IO的性能高

虚拟化和容器产品一览(截至2018.3.23)：

![](/assets/images/2018/virtualization-softwares.png)

## Docker原理分析

![](/assets/images/2018/docker-theory.jpeg)

### 镜像原理

镜像是一个只读的容器模板，含有启动docker容器所需的文件系统结构及内容

Docker以镜像和在镜像基础上构建的容器为基础，以容器开发、测试、发布的单元将应用相关的所有组件和环境进行封装，避免了应用在不同平台间迁移所带来的依赖问题，确保了应用在生产环境的各阶段达到高度一致的实际效果。

主要特点

 - 分层。镜像采用分层构建，每个镜像由一系列的镜像层组成,当需要修改容器内的某个文件时，只对处于最上方的读写层进行变动，不覆盖下面已有文件系统的内容。当提交这个修改过的容器文件系统为一个新的镜像时，保存的内容仅为最上层读写文件系统中被更新过的文件。

 ![](/assets/images/2018/docker-image.png)
 ![](/assets/images/2018/docker-fs.jpeg)

 - 写时复制。

    - 可以在多个容器之间共享镜像，每个容器启动时不需要单独复制一份镜像文件
    - 将所有镜像层以只读方式挂载到一个挂载点，在上面覆盖一个可读写的容器层。
    - 写时复制配合分层机制减少了镜像对磁盘空间的占用和容器启动时间

 - 内容寻址

    - 根据内容来索引镜像和镜像层
    - 是对镜像层的内容计算检验和，生成一个内容哈希值作为镜像层的唯一标识
    - 对于来自不同构建的镜像层，只要拥有相同的内容哈希，也能被不同镜像共享

 - 联合挂载

    - 可以在一个挂载点挂载多个文件系统，将挂载点的原目录与被挂在内容进行整合，最终可见的文件系统将包含整合后各层的文件和目录
    - 读写层处于容器文件系统的最顶层，其下可能联合挂载多个只读层。

### 存储管理

**元数据管理**

为了适应不同平台不同场景的存储需求，Docker提供了各种基于不同文件系统实现的存储驱动来管理实际的镜像文件

镜像在设计上将元数据和文件存储完全隔离。Docker管理元数据采用的也正是从上至下repository、image、layer是3个层次。所以repository与image两个元数据并无物理上的镜像文件与之对应，layer则存在物理上的镜像文件与之对应。

 - repository元数据：文件中存储了所有版本镜像的名字和tag以及对应的镜像ID（image/aufs）
 - image元数据：文件中存储了镜像架构、操作系统、默认配置、该镜像的容器ID和配置，构建镜像的历史信息以及rootfs组成（image/aufs/imagedb/content/sha256）
 - layer元数据：镜像层描述不可改变的镜像，容器层描述可读写的容器，容器层ID对应容器的ID。

**存储管理**

为支持写时复制特性，根据不同操作系统底层的支持提供不同的存储驱动。aufs（advanced multi layered unification file system）是一种支持联合挂载的文件系统，支持不同目录挂载到同一个目录，挂载对用户来说是透明的。

**数据卷**

volume是存在于一个或多个容器中的特定文件或文件夹，这个目录以独立联合文件系统的形式存在于宿主机中

 - 容器创建时就会初始化，在容器运行时就可以使用其中的文件
 - 能在不同的容器中共享和重用
 - 对volume中的数据操作不会影响到镜像本身
 - 生命周期独立，即使删除容器volume依然存在

**Namespace**

同一个namespace下的进程可以感知彼此的变化，而对外界进程一无所知
 - UTS 隔离主机名与域名
 - IPC 隔离信号量、消息队列和共享内存
 - PID 隔离进程编号
 - 不同的PID namespaces会形成一个层级体系
 - 每个pid namespace的第一个进程 pid 1会像传统linux的init进程号一样拥有特权
 - Net 隔离网络设备、网络栈、端口
 - Mount 隔离挂载点（文件系统）
 - User 隔离用户和用户组

**cgroup**

根据需求把一系列的系统任务和子任务整合到按资源划分等级的不同组内，从而为系统资源管理提供一个统计的框架

主要作用
 - 资源限制
 - 优先级分配
 - 资源统计
 - 任务控制
主要特点
 - cgroup的api是以一个为文件系统的方式实现，用户态的程序可以通过文件操作实现cgroup的组织管理
 - 组织管理操作单元可以细粒度到线程级别，可以创建和销毁cgroup从而实现资源再分配和管理
 - 所有资源管理的功能都以子系统的方式实现，接口统一
 - 子任务创建之初与父任务处于同一个cgroups控制组



